I'll create a comprehensive, single Agent 3 task that combines the TutorMind prompt with concrete implementation fixes for all the issues you're experiencing:

```markdown
AGENT 3 TASK — Complete AI Tutor Fix

## Fix all tutor issues: delayed responses, repeated questions, ignored answers, subject mixing, and non-inclusive language

### Step 1: Create Core Tutor Service
Create `server/services/tutorCore.ts`:
```typescript
// TutorMind Core - Handles all tutoring logic with strict rules
export class TutorCore {
  private sessionHistory = new Map<string, {
    lastQuestion: string;
    lastResponse: string;
    questionCount: Map<string, number>;
    subject: string;
  }>();

  getSystemPrompt(lessonPlan: any): string {
    const subject = lessonPlan?.subject || 'general';
    const topic = lessonPlan?.topic || 'learning';
    const step = lessonPlan?.currentStep || 'introduction';

    return `You are TutorMind, an AI tutor. CRITICAL RULES:

LESSON: Teaching ${topic} in ${subject} at step: ${step}

HARD RULES:
1. Stay ONLY on ${subject}. Never mention other subjects.
2. Maximum 2 sentences. Always end with a question.
3. ALWAYS acknowledge the student's answer first before continuing.
4. Never repeat the exact same question - rephrase with hints instead.
5. Use inclusive language: "let's count" not "show me fingers"

RESPONSE PATTERNS:
- Correct answer → "Excellent! [confirm]. [Next question]?"
- Wrong answer → "Not quite - it's [answer] because [reason]. Try this: [easier question]?"
- Confusion → "That's okay! Hint: [hint]. Can you try again?"
- Off-topic → "Interesting! But back to ${topic}: [question]?"

Current step content: ${JSON.stringify(lessonPlan?.content || {})}`;
  }

  processStudentAnswer(
    sessionId: string,
    studentAnswer: string,
    expectedAnswer: string | null,
    lessonPlan: any
  ): string {
    const session = this.sessionHistory.get(sessionId) || {
      lastQuestion: '',
      lastResponse: '',
      questionCount: new Map(),
      subject: lessonPlan?.subject || 'math'
    };

    let prefix = '';

    // Check if answer is correct (if we have an expected answer)
    if (expectedAnswer) {
      const isCorrect = this.checkAnswer(studentAnswer, expectedAnswer);
      
      if (isCorrect) {
        prefix = this.getRandomPhrase([
          "Perfect!",
          "Excellent work!",
          "That's right!",
          "Great job!",
          "Exactly!"
        ]);
      } else {
        prefix = `Good try! The answer is ${expectedAnswer}.`;
      }
    } else if (studentAnswer.length < 10) {
      // Short answers without expected - acknowledge them
      prefix = this.getRandomPhrase([
        "I see!",
        "Okay!",
        "Got it!",
        "Alright!"
      ]);
    }

    this.sessionHistory.set(sessionId, session);
    return prefix;
  }

  preventRepetition(sessionId: string, response: string): string {
    const session = this.sessionHistory.get(sessionId);
    if (!session) return response;

    // Check if this exact response was just used
    if (session.lastResponse === response) {
      const alternatives = {
        math: [
          "Let's try a different approach. What's one more than 2?",
          "Think about it this way: 2 plus 1 equals?",
          "Here's a hint: count 1, 2, and then?"
        ],
        english: [
          "Let me rephrase. Can you find the noun here?",
          "Another way to ask: which word is a person, place, or thing?",
          "Think about this: what's the action word?"
        ],
        default: [
          "Let's approach this differently. What do you think?",
          "Here's another way to look at it. Can you try?",
          "Think step by step. What comes next?"
        ]
      };

      const pool = alternatives[session.subject] || alternatives.default;
      response = pool[Math.floor(Math.random() * pool.length)];
    }

    // Track question frequency
    const questionKey = this.extractQuestion(response);
    const count = session.questionCount.get(questionKey) || 0;
    
    if (count >= 2) {
      // This question has been asked too many times
      response = this.getRephrasedQuestion(session.subject, questionKey);
      session.questionCount.clear(); // Reset counter
    } else {
      session.questionCount.set(questionKey, count + 1);
    }

    session.lastResponse = response;
    return response;
  }

  private checkAnswer(student: string, expected: string): boolean {
    const s1 = this.normalize(student);
    const s2 = this.normalize(expected);
    
    if (s1 === s2) return true;
    
    // Check numeric equivalence
    const num1 = this.parseNumber(s1);
    const num2 = this.parseNumber(s2);
    
    if (num1 !== null && num2 !== null) {
      return Math.abs(num1 - num2) < 0.01;
    }
    
    // MCQ check
    if (s2.length === 1 && /^[a-d]$/.test(s2)) {
      return s1 === s2 || 
             s1 === `option ${s2}` || 
             s1 === (s2.charCodeAt(0) - 96).toString();
    }
    
    return false;
  }

  private normalize(text: string): string {
    const numberWords: Record<string, string> = {
      'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',
      'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9',
      'ten': '10', 'eleven': '11', 'twelve': '12', 'thirteen': '13',
      'fourteen': '14', 'fifteen': '15', 'twenty': '20'
    };

    let normalized = text.toLowerCase().trim();
    
    Object.entries(numberWords).forEach(([word, digit]) => {
      normalized = normalized.replace(new RegExp(`\\b${word}\\b`, 'g'), digit);
    });
    
    return normalized.replace(/[^a-z0-9\s]/g, '').trim();
  }

  private parseNumber(text: string): number | null {
    const num = parseFloat(text);
    return isNaN(num) ? null : num;
  }

  private extractQuestion(text: string): string {
    const match = text.match(/([^.!?]*\?)/);
    return match ? match[1].trim() : text;
  }

  private getRephrasedQuestion(subject: string, original: string): string {
    const rephrases: Record<string, string[]> = {
      "what comes after 2?": [
        "What number is one more than 2?",
        "If you have 2 and add 1, you get?",
        "Count: 1, 2, then?"
      ],
      "what's 2 plus 2?": [
        "If you have 2 apples and get 2 more, how many total?",
        "Add 2 and 2 together. What do you get?",
        "Two groups of 2 makes?"
      ]
    };

    const key = original.toLowerCase();
    const options = rephrases[key];
    
    if (options) {
      return options[Math.floor(Math.random() * options.length)];
    }
    
    // Generic rephrase
    return `Let's think about this differently. ${original}`;
  }

  private getRandomPhrase(phrases: string[]): string {
    return phrases[Math.floor(Math.random() * phrases.length)];
  }

  enforceFormat(text: string): string {
    // Ensure max 2 sentences
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
    let result = sentences.slice(0, 2).join(' ').trim();
    
    // Ensure ends with question
    if (!result.endsWith('?')) {
      if (result.endsWith('.') || result.endsWith('!')) {
        result = result.slice(0, -1) + '?';
      } else {
        result += ' Ready to continue?';
      }
    }
    
    return result;
  }

  makeInclusive(text: string): string {
    const replacements: [RegExp, string][] = [
      [/\byour hand(s)?\b/gi, 'a hand'],
      [/\byour finger(s)?\b/gi, 'fingers'],
      [/\bshow me\b/gi, 'let\'s count'],
      [/\bcan you see\b/gi, 'notice'],
      [/\bstand up\b/gi, 'imagine standing'],
      [/\bjump\b/gi, 'count'],
      [/\bclap your hands\b/gi, 'count the beats'],
      [/\bpoint to\b/gi, 'think about'],
      [/\btouch\b/gi, 'imagine']
    ];

    let result = text;
    replacements.forEach(([pattern, replacement]) => {
      result = result.replace(pattern, replacement);
    });
    
    return result;
  }
}

export const tutorCore = new TutorCore();
```

### Step 2: Create Response Pipeline
Create `server/services/responsePipeline.ts`:
```typescript
import { tutorCore } from './tutorCore';

export async function processTutorResponse(
  rawResponse: string,
  sessionId: string,
  studentMessage: string,
  lessonPlan: any,
  expectedAnswer?: string
): Promise<string> {
  // Step 1: Process student's answer and add acknowledgment
  const acknowledgment = tutorCore.processStudentAnswer(
    sessionId,
    studentMessage,
    expectedAnswer || null,
    lessonPlan
  );

  // Step 2: Combine acknowledgment with response
  let response = acknowledgment ? `${acknowledgment} ${rawResponse}` : rawResponse;

  // Step 3: Make inclusive
  response = tutorCore.makeInclusive(response);

  // Step 4: Prevent repetition
  response = tutorCore.preventRepetition(sessionId, response);

  // Step 5: Enforce format (2 sentences, ends with ?)
  response = tutorCore.enforceFormat(response);

  // Step 6: Final subject check - ensure we stay on topic
  const subject = lessonPlan?.subject || 'math';
  const topic = lessonPlan?.topic || 'learning';
  
  // Remove any cross-subject references
  if (subject === 'math' && response.toLowerCase().includes('english')) {
    response = response.replace(/english|spelling|grammar|words/gi, 'numbers');
  } else if (subject === 'english' && response.toLowerCase().includes('math')) {
    response = response.replace(/math|numbers|counting|addition/gi, 'words');
  }

  // Ensure response mentions the current topic
  if (!response.toLowerCase().includes(topic.toLowerCase()) && topic !== 'general') {
    response = `Back to ${topic}. ${response}`;
  }

  return response;
}

export { tutorCore };
```

### Step 3: Update OpenAI Service (Minimal Changes)
Edit `server/services/openai.ts` - Add imports at top:
```typescript
import { processTutorResponse, tutorCore } from './responsePipeline';
```

In the `generateResponse` method, replace system prompt and process response:
```typescript
async generateResponse(message: string, sessionId: string, options?: any) {
  const lessonPlan = options?.lessonPlan || {};
  
  // Use TutorMind system prompt
  const systemPrompt = tutorCore.getSystemPrompt(lessonPlan);
  
  // Make the OpenAI call with proper error handling
  try {
    const completion = await this.openai.chat.completions.create({
      model: process.env.TUTOR_MODEL || 'gpt-4o-mini',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: message }
      ],
      max_tokens: 100, // Keep responses short
      temperature: 0.7,
      stream: false
    });

    const rawResponse = completion.choices[0].message.content || 
                        "Let's continue learning. What would you like to know?";

    // Process through pipeline
    const finalResponse = await processTutorResponse(
      rawResponse,
      sessionId,
      message,
      lessonPlan,
      options?.expectedAnswer
    );

    return { response: finalResponse };
    
  } catch (error: any) {
    // Handle 429 rate limiting with lesson-specific fallback
    if (error.status === 429) {
      const subject = lessonPlan?.subject || 'math';
      const fallbacks: Record<string, string> = {
        math: "Let's practice counting: 1, 2, 3. What comes next?",
        english: "Can you spell 'cat'? What's the first letter?",
        science: "Think about water. Is it a solid or liquid?",
        default: "Let's learn together. What interests you most?"
      };
      
      return { 
        response: fallbacks[subject] || fallbacks.default,
        fallback: true 
      };
    }
    
    throw error;
  }
}
```

### Step 4: Create Speed Optimization Service
Create `server/services/speedOptimizer.ts`:
```typescript
export class SpeedOptimizer {
  private cache = new Map<string, { response: string; timestamp: number }>();
  private readonly cacheTimeout = 60000; // 1 minute

  getCached(key: string): string | null {
    const entry = this.cache.get(key);
    if (entry && Date.now() - entry.timestamp < this.cacheTimeout) {
      return entry.response;
    }
    return null;
  }

  setCache(key: string, response: string): void {
    this.cache.set(key, { response, timestamp: Date.now() });
    
    // Cleanup old entries
    if (this.cache.size > 100) {
      const oldest = Array.from(this.cache.entries())
        .sort((a, b) => a[1].timestamp - b[1].timestamp)[0];
      this.cache.delete(oldest[0]);
    }
  }

  shouldProcessImmediately(text: string, confidence: number): boolean {
    // Process immediately if confidence is high and text is complete
    return (
      confidence >= 0.3 &&
      text.trim().length > 0 &&
      text.trim().length < 100 && // Short utterances only
      /[.!?]$/.test(text.trim()) || // Ends with punctuation
      text.split(' ').length <= 5 // Or very short
    );
  }
}

export const speedOptimizer = new SpeedOptimizer();
```

### Step 5: Update Voice Routes for Speed
Edit `server/routes/voiceRoutes.ts` - Add immediate processing:
```typescript
import { speedOptimizer } from '../services/speedOptimizer';

// In POST /conversation handler:
router.post('/conversation', async (req, res) => {
  const { message, userId, sessionId, confidence = 0.8 } = req.body;
  
  // Check cache first for instant response
  const cacheKey = `${sessionId}:${message.toLowerCase().trim()}`;
  const cached = speedOptimizer.getCached(cacheKey);
  
  if (cached) {
    return res.json({ response: cached, cached: true });
  }
  
  // Process immediately if high confidence
  if (!speedOptimizer.shouldProcessImmediately(message, confidence)) {
    // Wait minimal time for silence
    await new Promise(r => setTimeout(r, 200));
  }
  
  try {
    const result = await openAIService.generateResponse(
      message,
      sessionId,
      { lessonPlan: req.body.lessonPlan, expectedAnswer: req.body.expectedAnswer }
    );
    
    // Cache for repeated questions
    speedOptimizer.setCache(cacheKey, result.response);
    
    res.json(result);
  } catch (error) {
    console.error('Voice processing error:', error);
    res.json({ 
      response: "Let's continue. Can you repeat that?",
      error: true 
    });
  }
});
```

### Step 6: Environment Variables
Update `.env`:
```bash
# Tutor Configuration
TUTOR_MODEL=gpt-4o-mini
TUTOR_MAX_TOKENS=100
TUTOR_TEMPERATURE=0.7

# Speed Settings (reduced for faster response)
ASR_MIN_MS=150
ASR_MIN_CONFIDENCE=0.3
VAD_SILENCE_MS=200
RESPONSE_CACHE_TIMEOUT=60000
```

### Step 7: Create Comprehensive Tests
Create `tests/tutor-complete.test.ts`:
```typescript
import { describe, test, expect } from '@jest/globals';
import { tutorCore } from '../server/services/tutorCore';

describe('Complete Tutor Fix Tests', () => {
  const sessionId = 'test-session';
  const mathLesson = {
    subject: 'math',
    topic: 'addition',
    currentStep: 'practice'
  };
  const englishLesson = {
    subject: 'english',
    topic: 'nouns',
    currentStep: 'introduction'
  };

  test('Never mixes subjects', () => {
    const mathPrompt = tutorCore.getSystemPrompt(mathLesson);
    expect(mathPrompt).toContain('math');
    expect(mathPrompt).toContain('addition');
    expect(mathPrompt).not.toContain('english');
    expect(mathPrompt).not.toContain('spelling');
  });

  test('Always acknowledges student answers', () => {
    // Correct answer
    let ack = tutorCore.processStudentAnswer(sessionId, '3', '3', mathLesson);
    expect(ack).toMatch(/perfect|excellent|right|great|exactly/i);
    
    // Wrong answer
    ack = tutorCore.processStudentAnswer(sessionId, '5', '3', mathLesson);
    expect(ack).toContain('3');
    expect(ack).toMatch(/try|answer is/i);
  });

  test('Prevents repetition', () => {
    const response1 = "What comes after 2?";
    const response2 = tutorCore.preventRepetition(sessionId, response1);
    const response3 = tutorCore.preventRepetition(sessionId, response1);
    
    expect(response2).toBe(response1); // First time is OK
    expect(response3).not.toBe(response1); // Should rephrase
    expect(response3).toContain('?'); // Still a question
  });

  test('Makes language inclusive', () => {
    const tests = [
      ["Show me your fingers", "fingers"],
      ["Clap your hands", "count"],
      ["Stand up and jump", "imagine"],
      ["Point to your nose", "think about"]
    ];
    
    tests.forEach(([input, shouldContain]) => {
      const result = tutorCore.makeInclusive(input);
      expect(result.toLowerCase()).not.toContain('your hand');
      expect(result.toLowerCase()).not.toContain('stand up');
      if (shouldContain) {
        expect(result.toLowerCase()).toContain(shouldContain);
      }
    });
  });

  test('Enforces 2-sentence question format', () => {
    const long = "Great job! You got it right. The answer is 3. Now let's try another one.";
    const formatted = tutorCore.enforceFormat(long);
    
    const sentences = formatted.match(/[.!?]+/g) || [];
    expect(sentences.length).toBeLessThanOrEqual(2);
    expect(formatted.endsWith('?')).toBe(true);
  });

  test('Normalizes number words correctly', () => {
    const core = tutorCore as any; // Access private method
    expect(core.normalize('three')).toBe('3');
    expect(core.normalize('FOUR')).toBe('4');
    expect(core.normalize('twenty')).toBe('20');
  });

  test('Check answer handles multiple formats', () => {
    const core = tutorCore as any;
    
    // Math answers
    expect(core.checkAnswer('3', '3')).toBe(true);
    expect(core.checkAnswer('three', '3')).toBe(true);
    expect(core.checkAnswer('THREE', '3')).toBe(true);
    
    // MCQ answers
    expect(core.checkAnswer('b', 'b')).toBe(true);
    expect(core.checkAnswer('option b', 'b')).toBe(true);
    expect(core.checkAnswer('2', 'b')).toBe(true); // b = 2nd option
  });

  test('Speed optimizer identifies quick responses', () => {
    const { shouldProcessImmediately } = require('../server/services/speedOptimizer').speedOptimizer;
    
    expect(shouldProcessImmediately('Yes.', 0.9)).toBe(true);
    expect(shouldProcessImmediately('three', 0.8)).toBe(true);
    expect(shouldProcessImmediately('I dont know', 0.7)).toBe(true);
    
    // Long or low confidence should wait
    expect(shouldProcessImmediately('mumble mumble', 0.2)).toBe(false);
    expect(shouldProcessImmediately('This is a very long response that...', 0.9)).toBe(false);
  });
});
```

### Acceptance Criteria Checklist
✅ **No subject mixing** - Math stays math, English stays English
✅ **No repetition** - Questions are rephrased with hints, never repeated verbatim
✅ **Answer acknowledgment** - Every student input gets explicit feedback
✅ **Fast responses** - 150-200ms processing, with caching for common questions
✅ **Inclusive language** - No physical commands or assumptions
✅ **Consistent format** - Always 2 sentences max, ending with question
✅ **429 handling** - Lesson-specific fallbacks without loops
✅ **No fabrication** - Never makes up user turns

### Run Tests
```bash
npm test tests/tutor-complete.test.ts
```

### Test Live
```bash
# Test math lesson
curl -X POST http://localhost:5000/api/voice/conversation \
  -H "Content-Type: application/json" \
  -d '{
    "message": "five",
    "userId": "test-user",
    "sessionId": "test-session",
    "lessonPlan": {
      "subject": "math",
      "topic": "addition",
      "currentStep": "practice"
    },
    "expectedAnswer": "3"
  }'

# Response should acknowledge wrong answer and stay in math
```
```

This complete solution addresses all your issues with modular services, minimal changes to existing code, and comprehensive testing. The tutor will now respond quickly, stay on subject, acknowledge all answers, and never repeat questions.